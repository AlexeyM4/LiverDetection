<!DOCTYPE html>
{% load static %}
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="{% static 'detectionApp/css/edit_page.css' %}" rel="stylesheet" type="text/css"/>
    <title>Редактирование</title>
</head>
<body>
    <div class="container">
        <h1>Редактирование</h1>
        <div class="gallery">
            <img src="{% static 'detectionApp/media/imagesOverlay/' %}{{ image_name }}" alt="{{ image }}">
            <img src="{% static 'detectionApp/media/images/' %}{{ image_name }}"
                 alt="{{ image }}"
                 style="display:none;"
                 id="img_{{ image_name|slugify }}">
            <canvas id="canvas_{{ image_name|slugify }}" width="450" height="450"></canvas>
        </div>
        <a href="{% url 'results' %}"><button>Назад</button></a>
        <button onclick="saveCanvas('{{ image_name|slugify }}', '{{ image_name }}')">Сохранить</button>
        <button onclick="undoLastLine('{{ image_name|slugify }}')">Отменить последнюю фигуру</button>
    </div>
    <script>
        // Хранилище фигур для каждого канваса
        const canvasFigures = {};

        document.querySelectorAll('canvas').forEach(canvas => {
            const imageName = canvas.id.split('_')[1];
            const ctx = canvas.getContext('2d');
            const img = document.getElementById('img_' + imageName);

            // Фигуры для данного канваса
            canvasFigures[imageName] = [];
            let isDrawing = false;
            let currentFigure = []; // Для хранения точек текущей фигуры

            // Загружаем изображение на канвас
            img.onload = () => {
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            };
            img.src = img.src; // Принудительная загрузка

            // Функция для начала рисования
            canvas.addEventListener('mousedown', (e) => {
                isDrawing = true;
                currentFigure = []; // Начинаем новую фигуру
                currentFigure.push({ x: e.offsetX, y: e.offsetY }); // Начальная точка
            });

            // Функция для рисования
            canvas.addEventListener('mousemove', (e) => {
                if (!isDrawing) return;
                const lastPoint = currentFigure[currentFigure.length - 1];
                ctx.beginPath();
                ctx.moveTo(lastPoint.x, lastPoint.y);
                ctx.lineTo(e.offsetX, e.offsetY);
                ctx.strokeStyle = 'red';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Добавляем точку в текущую фигуру
                currentFigure.push({ x: e.offsetX, y: e.offsetY });
            });

            // Функция для завершения рисования
            canvas.addEventListener('mouseup', () => {
                if (!isDrawing) return;
                isDrawing = false;
                canvasFigures[imageName].push(currentFigure); // Сохраняем фигуру
            });

            canvas.addEventListener('mouseout', () => {
                if (isDrawing) {
                    isDrawing = false;
                    canvasFigures[imageName].push(currentFigure); // Сохраняем фигуру
                }
            });
        });

        // Функция для отмены последней фигуры
        function undoLastLine(imageName) {
            const canvas = document.getElementById('canvas_' + imageName);
            const ctx = canvas.getContext('2d');
            const img = document.getElementById('img_' + imageName);

            if (!canvasFigures[imageName] || canvasFigures[imageName].length === 0) {
                console.warn('Нет фигур для отмены');
                return;
            }

            // Удаляем последнюю фигуру
            canvasFigures[imageName].pop();

            // Перерисовываем канвас
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

            // Перерисовываем оставшиеся фигуры
            canvasFigures[imageName].forEach(figure => {
                ctx.beginPath();
                for (let i = 1; i < figure.length; i++) {
                    const start = figure[i - 1];
                    const end = figure[i];
                    ctx.moveTo(start.x, start.y);
                    ctx.lineTo(end.x, end.y);
                    ctx.strokeStyle = 'red';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            });
        }

        // Функция для сохранения канваса
        function saveCanvas(imageName, originalName) {
            const canvas = document.getElementById('canvas_' + imageName);
            if (!canvas) {
                console.error('Канвас не найден для:', imageName);
                return;
            }

            const dataURL = canvas.toDataURL('image/png');
            const link = document.createElement('a');
            link.href = dataURL;
            link.download = originalName.replace('_overlay.png', '_edited.png');
            link.click();
        }
    </script>
</body>
</html>
